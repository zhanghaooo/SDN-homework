# OvS阅读总结

## OvS的特点：

1.OvS是一个通用网络应用，需要支持所有类型的需求，例如L2 MAC地址的匹配，L3 IP地址（DIP和SIP）的匹配，L4 端口匹配，生存时间限制，包头域修改等；

2.OvS强调的是对一般情况的支持，而不是对最坏情况的支持，也就是说，OvS只需要在平均情况下达到良好性能；

3.OvS布置在网络的边缘，随时会进行交换状态（流表）的更新；

4.OvS里有两个主要构件用来进行包转发，一个是ivs-vswitchd，这个各平台通用，另一个是datapath kernel module，这个平台独立；前者在用户态，后者在内核态，当一个报文到达的时候，首先在内核态中查找匹配项，如果没有找到，就转发到用户态的ivs-vswitchd，然后将这一条表项添加到内核态中

5.micorflow cache是针对一条流建立的缓存表项，megaflow是针对一系列流的集合建立一个缓存表项，这个集合中的所有流都有相同的转发动作，而且都可以通过一个前缀匹配到；在有了megaflow cache之后，microflow cache找给你存储的实际上不再是转发表项，而是megaflow cache的索引；

6.元组分类搜索：元组指的是报文头部中每一个需要匹配的域，例如SIP，DIP，MAC等等，每一个元组都会建立一个哈希表，新来的报文通过匹配每一个元组，得到转发动作。元组分类搜索支持O(1)时间内的更新操作，支持任意形式的报文的匹配而不需要改变匹配算法本身，使用O(1)内存空间

7.OvS提出了“resubmit”方法，解决了“交叉相乘问题”：如果元组空间搜索要匹配两个域A和B，A中有n1条表项，B中n2条表项，如果要用一个表为所有的流建立缓存，那么缓存中一定会有n1*n2条表项。如果A和B是无关的，那么一定有一些A与B的叉乘项是永远不会被匹配到的，因此可以采用两个表来分别缓存A和B，然后将A和B的匹配结果结合起来得到转发动作

8.microflow的来历：

OvS创建之初，因为发现内核态处理报文能够得到非常的快，因此将所有的报文处理全部放到内核态进行，也就是全部列表项都放在内核态中。但是因为在内核态开发十分的麻烦，而且每次更新到涉及到内核的部署和更新，于是这一方法被放弃了。

当前（2.0）版本的OvS使用了一种新的方法，用microflow cache实现内核模块，缓存中的表项是报文全部的域的精确匹配项。但是使用这种方法有很多问题，其中一个是流的建立非常的慢，因此采用了攒多个流一起建立缓存，和使用多线程利用多核优势的方法

9.mageflow cache：支持通项匹配；所有表项没有优先级；匹配只在一个表中进行，而不是一系列的表连续匹配。

10.因为OvS要支持所有类型报文的匹配，因此megaflow cache中必须包含所有需要匹配的包头域，因此，megaflow cache中可能会有无用的匹配项，无用表项多了之后，就会使得比配速度变慢。为了优化，采用了三种方法

元组优先排序：先匹配优先级高的字段，匹配到了就可以停止匹配

阶梯查询：megaflow只匹配包头域的子集，而不需要匹配tuple中的所有字段。问题是如何确定子集：

将所有的域划分为四组：元数据，L2，L3，L4，然后划分四个检查等级：
一、检查元数据
二、检查元数据和L2域
三、检查元数据、L2、L3域
四、检查所有域
四个等级依次检查，只有匹配成功的等级里面的域会被添加到megaflow table中

前缀查询：使用字典树匹配IP字段，避免匹配全部的IP的全部32位

分类器分割：为每一个域创建一个典型元数据，这个元数据匹配所有的合格流，如果一个流不符合元数据，那么将不会符合下一步分类的任何结果

11.缓存有效性检查：因为流表更新等原因，缓存可能会需要更新。

优先级：当有高优先级的路由表项加进来的时候，原先存储在缓存里面的所有低优先级表项都要修改

大范围更新：每次在缓存中命中之后，都返回用户态查流表，比较两次匹配的结果，如果不一样，则更新缓存；

小范围更新：为每一个域的每一项都给定一个标签tag，将所有改变了的域的项的标签加入一个tag集合，周期性的遍历缓存和tag集合，如果发现缓存表项中有tag集合中对应的域，那么更新这一个表项。因为OvS控制器的应用会不断变复杂，而且OvS中会增加更多会随着网络状态改变的转发动作，每一个周期都会更新更多的表项，因此这一方法被OvS放弃了。

12.大范围更新的问题：

在更新缓存表项的时候，不能为新来的流建立表项，这些流所包含的报文都会被阻塞。解决办法是采用多线程，使得更新缓存的时候还能建立新的表项。

为了提高大范围更新的速度，采用多线程建立缓存表项。但是流的删除还是单线程，因此可能会出现流建立速度超过流删除速度，导致内核空间被迅速充满。OvS2.1中对流的删除也采用了多线程，使得流的删除的速度平衡了流的建立速度。

13.流的老化：

缓存的流表项不能一直存储在内核中，一些很少用到的缓存表项应该被删除。目前采用的是生存时间，如果一个表项在一定时间内没被使用，那么就删除这个表项。
